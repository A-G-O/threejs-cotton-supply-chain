<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cotton Supply Chain Simulation</title>
  <style>
    /* Basic reset and full-screen canvas */
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    /* UI controls overlay */
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 4px;
    }
    #ui button {
      margin: 5px;
      padding: 5px 10px;
      font-size: 14px;
    }
    #ui label {
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- UI Controls -->
  <div id="ui">
    <button id="prevStage">Previous Stage</button>
    <button id="nextStage">Next Stage</button>
    <br>
    <label>
      Animation Speed:
      <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1">
    </label>
  </div>

  <!-- Three.js Script -->
  <script type="module">
    /***********************************************************************
     * Cotton Supply Chain Simulation using Three.js
     *
     * This demo simulates the journey of cotton from raw growth to final 
     * product distribution. Each stage is represented by a different group
     * with unique models and particle effects. Camera transitions and basic 
     * UI controls enhance interactivity.
     *
     * Setup Instructions:
     * 1. Save this file as index.html.
     * 2. Run a local server (e.g., using "python -m http.server").
     * 3. Open the browser and navigate to the local server URL.
     ***********************************************************************/

    // Import Three.js and OrbitControls from CDN
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/controls/OrbitControls.js';

    // Global variables for scene, camera, renderer, controls, and animation speed.
    let scene, camera, renderer, controls;
    let animationSpeed = 1;
    let clock = new THREE.Clock();

    // Array to hold each stageâ€™s group
    const stageGroups = [];
    let currentStageIndex = 0;

    // Global references for objects that need to be accessed across functions
    let cottonFieldGroup, cottonParticles;
    let harvestingGroup, machine;
    let ginningGroup, seedParticles, ginningBuilding;
    let textileGroup, spinningParticles;
    let distributionGroup, conveyor;

    // Setup camera positions (and target lookAt) for each stage
    const cameraPositions = [
      { position: new THREE.Vector3(0, 30, 50), target: new THREE.Vector3(0, 0, 0) },  // Cotton Fields
      { position: new THREE.Vector3(0, 20, 40), target: new THREE.Vector3(0, 0, 0) },  // Harvesting Machinery
      { position: new THREE.Vector3(30, 25, 40), target: new THREE.Vector3(0, 0, 0) }, // Ginning Facilities
      { position: new THREE.Vector3(40, 30, 30), target: new THREE.Vector3(0, 0, 0) }, // Textile Factories
      { position: new THREE.Vector3(0, 40, 60), target: new THREE.Vector3(0, 0, 0) }   // Distribution Centers
    ];

    // Variables for camera transition
    let cameraTransitionTime = 0;
    const transitionDuration = 2; // seconds
    let cameraStartPos = new THREE.Vector3();
    let cameraStartTarget = new THREE.Vector3();
    let cameraEndPos = new THREE.Vector3();
    let cameraEndTarget = new THREE.Vector3();

    // ------------------------------------------------------
    // Initialization: scene, camera, renderer, controls, lights
    // ------------------------------------------------------
    init();
    animate();

    function init() {
      // Create the main scene and set a light blue background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xa0d0ff);

      // Create the perspective camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.copy(cameraPositions[0].position);

      // Set up the WebGL renderer with antialiasing
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add OrbitControls for interactive camera movements
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.copy(cameraPositions[0].target);
      controls.update();

      // Lighting: Ambient and directional light for a balanced scene
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      scene.add(directionalLight);

      // Create and add each stage group
      stageGroups.push(createCottonFields());
      stageGroups.push(createHarvestingMachinery());
      stageGroups.push(createGinningFacilities());
      stageGroups.push(createTextileFactories());
      stageGroups.push(createDistributionCenter());

      // Add all stage groups to the scene but only show the first stage initially.
      stageGroups.forEach((group, index) => {
        group.visible = (index === currentStageIndex);
        scene.add(group);
      });

      // Setup event listeners for window resize and UI controls
      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('prevStage').addEventListener('click', prevStage);
      document.getElementById('nextStage').addEventListener('click', nextStage);
      document.getElementById('speedControl').addEventListener('input', (e) => {
        animationSpeed = parseFloat(e.target.value);
      });
    }

    // Adjust renderer and camera on window resize.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ------------------------------------------------------
    // Animation Loop: Updates each stage and camera transitions.
    // ------------------------------------------------------
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta() * animationSpeed;

      // Update the current stage animations
      updateCottonFields(delta);
      updateHarvestingMachinery(delta);
      updateGinningFacilities(delta);
      updateTextileFactories(delta);
      updateDistributionCenter(delta);

      // Smooth camera transition update
      updateCameraTransition(delta);

      renderer.render(scene, camera);
    }

    // ------------------------------------------------------
    // Stage Transition Functions and Camera Transition Handling
    // ------------------------------------------------------
    // Change stage (show/hide groups) and reset camera transition.
    function setStage(index) {
      stageGroups.forEach((group, i) => {
        group.visible = (i === index);
      });
      currentStageIndex = index;
      setCameraForStage(index);
    }

    function prevStage() {
      const newIndex = (currentStageIndex - 1 + stageGroups.length) % stageGroups.length;
      setStage(newIndex);
    }

    function nextStage() {
      const newIndex = (currentStageIndex + 1) % stageGroups.length;
      setStage(newIndex);
    }

    // Initiate a smooth camera transition toward the defined camera position for the given stage.
    function setCameraForStage(stageIndex) {
      cameraTransitionTime = 0;
      cameraStartPos = camera.position.clone();
      cameraStartTarget = controls.target.clone();
      cameraEndPos = cameraPositions[stageIndex].position.clone();
      cameraEndTarget = cameraPositions[stageIndex].target.clone();
    }

    // Lerp the camera position and target during transitions.
    function updateCameraTransition(delta) {
      if (cameraTransitionTime < transitionDuration) {
        cameraTransitionTime += delta;
        let t = Math.min(cameraTransitionTime / transitionDuration, 1);
        // Smoothstep easing for a smoother transition
        t = t * t * (3 - 2 * t);
        camera.position.lerpVectors(cameraStartPos, cameraEndPos, t);
        controls.target.lerpVectors(cameraStartTarget, cameraEndTarget, t);
        controls.update();
      }
    }

    // ------------------------------------------------------
    // Stage 1: Cotton Fields (Raw cotton growth)
    // ------------------------------------------------------
    function createCottonFields() {
      cottonFieldGroup = new THREE.Group();

      // Create a large green plane to represent a cotton field.
      const fieldGeometry = new THREE.PlaneGeometry(100, 100);
      const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Forest Green
      const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
      fieldMesh.rotation.x = -Math.PI / 2;
      cottonFieldGroup.add(fieldMesh);

      // Scatter small white spheres to represent cotton bolls.
      const bollGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const bollMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
      for (let i = 0; i < 200; i++) {
        const boll = new THREE.Mesh(bollGeometry, bollMaterial);
        boll.position.set(
          Math.random() * 100 - 50,
          0.5,
          Math.random() * 100 - 50
        );
        cottonFieldGroup.add(boll);
      }

      // Particle system for ambient cotton fluff.
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 500;
      const positions = [];
      for (let i = 0; i < particlesCount; i++) {
        positions.push(
          Math.random() * 100 - 50,
          Math.random() * 5 + 1,
          Math.random() * 100 - 50
        );
      }
      particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const particlesMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
      cottonParticles = new THREE.Points(particlesGeometry, particlesMaterial);
      cottonFieldGroup.add(cottonParticles);

      return cottonFieldGroup;
    }

    // Gently rotate the cotton fluff particles for a subtle animation.
    function updateCottonFields(delta) {
      if (cottonParticles) {
        cottonParticles.rotation.y += delta * 0.1;
      }
    }

    // ------------------------------------------------------
    // Stage 2: Harvesting Machinery
    // ------------------------------------------------------
    function createHarvestingMachinery() {
      harvestingGroup = new THREE.Group();

      // Reuse the cotton field background from Stage 1.
      const fieldMesh = stageGroups[0].children.find(obj => obj.geometry && obj.geometry.type === "PlaneGeometry").clone();
      harvestingGroup.add(fieldMesh);

      // Create a simple harvesting machine (a box with a rotating arm).
      const machineBodyGeometry = new THREE.BoxGeometry(4, 2, 6);
      const machineBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
      machine = new THREE.Mesh(machineBodyGeometry, machineBodyMaterial);
      machine.position.set(-40, 1, 0);
      harvestingGroup.add(machine);

      // Add a rotating arm (a thin box) to simulate the harvesting mechanism.
      const armGeometry = new THREE.BoxGeometry(0.5, 0.5, 4);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      const arm = new THREE.Mesh(armGeometry, armMaterial);
      arm.position.set(0, 1.5, -2);
      arm.name = "arm";
      machine.add(arm);

      return harvestingGroup;
    }

    // Animate the harvesting machine moving across the field and its arm rotating.
    function updateHarvestingMachinery(delta) {
      if (!harvestingGroup.visible) return;

      // Move the machine horizontally across the scene.
      machine.position.x += delta * 5; // Speed: 5 units per second.
      if (machine.position.x > 40) {
        machine.position.x = -40;
      }
      // Rotate the arm continuously.
      const arm = machine.getObjectByName("arm");
      if (arm) {
        arm.rotation.z += delta * 2;
      }
    }

    // ------------------------------------------------------
    // Stage 3: Ginning Facilities (Cotton Processing)
    // ------------------------------------------------------
    function createGinningFacilities() {
      ginningGroup = new THREE.Group();

      // Create a simple building to represent a ginning facility.
      const buildingGeometry = new THREE.BoxGeometry(30, 15, 20);
      const buildingMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
      ginningBuilding = new THREE.Mesh(buildingGeometry, buildingMaterial);
      ginningBuilding.position.set(0, 7.5, 0);
      ginningGroup.add(ginningBuilding);

      // Add a chimney to simulate a factory environment.
      const chimneyGeometry = new THREE.CylinderGeometry(1, 1, 8, 16);
      const chimneyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
      chimney.position.set(10, 15, 0);
      ginningGroup.add(chimney);

      // Particle system to simulate seed separation during cotton processing.
      const seedGeometry = new THREE.BufferGeometry();
      const seedCount = 300;
      const seedPositions = [];
      for (let i = 0; i < seedCount; i++) {
        seedPositions.push(
          ginningBuilding.position.x + (Math.random() - 0.5) * 10,
          ginningBuilding.position.y + Math.random() * 5,
          ginningBuilding.position.z + (Math.random() - 0.5) * 10
        );
      }
      seedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(seedPositions, 3));
      const seedMaterial = new THREE.PointsMaterial({ color: 0xffff00, size: 0.3 });
      seedParticles = new THREE.Points(seedGeometry, seedMaterial);
      ginningGroup.add(seedParticles);

      return ginningGroup;
    }

    // Animate the seed particles to simulate upward movement (e.g., separation).
    function updateGinningFacilities(delta) {
      if (!ginningGroup.visible) return;
      if (seedParticles) {
        const positions = seedParticles.geometry.attributes.position.array;
        for (let i = 1; i < positions.length; i += 3) {
          positions[i] += delta * 0.5; // Slowly move upward.
          // Reset position if particle has moved too high.
          if (positions[i] > 25) {
            positions[i] = ginningBuilding.position.y + Math.random() * 5;
          }
        }
        seedParticles.geometry.attributes.position.needsUpdate = true;
      }
    }

    // ------------------------------------------------------
    // Stage 4: Textile Factories (Manufacturing Process)
    // ------------------------------------------------------
    function createTextileFactories() {
      textileGroup = new THREE.Group();

      // Create a factory building.
      const factoryGeometry = new THREE.BoxGeometry(40, 20, 30);
      const factoryMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
      const factory = new THREE.Mesh(factoryGeometry, factoryMaterial);
      factory.position.set(0, 10, 0);
      textileGroup.add(factory);

      // Add rotating cylinders to represent spinning machines.
      for (let i = -1; i <= 1; i++) {
        const cylinderGeometry = new THREE.CylinderGeometry(1, 1, 4, 16);
        const cylinderMaterial = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(i * 5, 12, 0);
        cylinder.rotation.z = Math.PI / 2;
        cylinder.name = "spinningMachine";
        textileGroup.add(cylinder);
      }

      // Particle system to simulate fabric creation.
      const spinningGeometry = new THREE.BufferGeometry();
      const spinningCount = 400;
      const spinningPositions = [];
      for (let i = 0; i < spinningCount; i++) {
        spinningPositions.push(
          Math.random() * 10 - 5,
          Math.random() * 5 + 10,
          Math.random() * 10 - 5
        );
      }
      spinningGeometry.setAttribute('position', new THREE.Float32BufferAttribute(spinningPositions, 3));
      const spinningMaterial = new THREE.PointsMaterial({ color: 0xffc0cb, size: 0.2 });
      spinningParticles = new THREE.Points(spinningGeometry, spinningMaterial);
      textileGroup.add(spinningParticles);

      return textileGroup;
    }

    // Rotate the spinning machines and animate the fabric particles.
    function updateTextileFactories(delta) {
      if (!textileGroup.visible) return;
      textileGroup.children.forEach(child => {
        if (child.name === "spinningMachine") {
          child.rotation.x += delta * 2;
        }
      });
      if (spinningParticles) {
        spinningParticles.rotation.y += delta * 0.5;
      }
    }

    // ------------------------------------------------------
    // Stage 5: Distribution Centers (Finished Products Distribution)
    // ------------------------------------------------------
    function createDistributionCenter() {
      distributionGroup = new THREE.Group();

      // Create a warehouse building.
      const warehouseGeometry = new THREE.BoxGeometry(50, 25, 40);
      const warehouseMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
      const warehouse = new THREE.Mesh(warehouseGeometry, warehouseMaterial);
      warehouse.position.set(0, 12.5, 0);
      distributionGroup.add(warehouse);

      // Create a conveyor belt represented by a long, thin box.
      const conveyorGeometry = new THREE.BoxGeometry(40, 1, 5);
      const conveyorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      conveyor = new THREE.Mesh(conveyorGeometry, conveyorMaterial);
      conveyor.position.set(0, 2, 10);
      distributionGroup.add(conveyor);

      // Add boxes along the conveyor to represent finished products.
      for (let i = -2; i <= 2; i++) {
        const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(i * 4, 3, 10);
        distributionGroup.add(box);
      }

      return distributionGroup;
    }

    // Animate the conveyor belt (by moving its position) to simulate product distribution.
    function updateDistributionCenter(delta) {
      if (!distributionGroup.visible) return;
      conveyor.position.x += delta * 2;
      if (conveyor.position.x > 10) {
        conveyor.position.x = -10;
      }
    }
  </script>
</body>
</html>
